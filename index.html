<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no, viewport-fit=cover">
    <meta http-equiv="Content-Security-Policy" content="default-src 'self'; script-src 'self' 'unsafe-inline' https://www.youtube.com; frame-src https://www.youtube.com; style-src 'self' 'unsafe-inline'; connect-src 'self' https://*.googleapis.com;">
    <title>Killtime</title>
    <style>
        :root {
            --primary-color: #3aff7f;
            --primary-color-rgb: 58, 255, 127;
            --bg-color: #121212;
            --text-color: #FFFFFF;
            --secondary-bg: #282828;
            --error-bg: rgba(58, 255, 127, 0.1);
        }

        body {
            margin: 0;
            font-family: 'Inter', -apple-system, BlinkMacSystemFont, sans-serif;
            min-height: 100vh;
            display: flex;
            flex-direction: column;
            align-items: center;
            background: var(--bg-color);
            color: var(--text-color);
            overflow: hidden;
            touch-action: none;
            position: fixed;
            width: 100%;
            height: 100%;
        }

        .container {
            max-width: 800px;
            width: 90%;
            padding: 40px 20px;
            text-align: center;
            margin: 0 auto;
            overflow-y: auto;
            -webkit-overflow-scrolling: touch;
            height: 100%;
        }

        h1 {
            font-size: min(8vw, 2.5rem);
            margin-bottom: 2rem;
            text-align: center;
            color: var(--primary-color);
            font-weight: 800;
            letter-spacing: -0.5px;
            -webkit-text-fill-color: var(--primary-color);
            background: none;
        }

        @media (max-width: 768px) {
            h1 {
                font-size: 2rem;
                margin-bottom: 1.5rem;
            }
            
            .container {
                padding: 20px 10px;
                width: 95%;
            }
        }

        @media (orientation: landscape) {
            .container {
                display: flex;
                flex-wrap: wrap;
                justify-content: center;
                align-items: center;
                max-width: 100%;
            }
            
            h1 {
                width: 100%;
                margin-bottom: 1rem;
            }
            
            .dial-container {
                width: 300px;
                height: 300px;
                margin: 0;
                flex-shrink: 0;
            }
            
            .form-container {
                width: 45%;
                margin-left: 5%;
                display: flex;
                flex-direction: column;
                align-items: center;
            }
        }

        .progress-container {
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 24px;
            background: rgba(0, 0, 0, 0.5);
            z-index: 2005;
            display: none;
            transition: opacity 0.3s ease;
            overflow: visible;
        }

        .progress-bar {
            height: 100%;
            width: 0%;
            transition: width 0.5s linear;
            box-shadow: 0 0 10px rgba(var(--primary-color-rgb), 0.5);
            position: relative;
            background: var(--primary-color);
        }

        .progress-time {
            position: absolute;
            right: 10px;
            top: 0;
            color: var(--primary-color);
            font-weight: bold;
            font-size: 16px;
            line-height: 24px;
            opacity: 1;
            text-shadow: 0 0 5px rgba(0, 0, 0, 0.7);
        }

        .dial-container {
            margin: 30px auto;
            position: relative;
            width: 300px;
            height: 300px;
            padding: 0;
            max-width: 100%;
        }

        .dial {
            width: 100%;
            height: 100%;
            border-radius: 50%;
            background: var(--secondary-bg);
            box-shadow: 0 0 50px rgba(var(--primary-color-rgb), 0.2);
            position: relative;
            cursor: pointer;
            border: 2px solid var(--primary-color);
            touch-action: none;
            box-sizing: border-box;
        }

        .dial-fill {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            border-radius: 50%;
            pointer-events: none;
        }

        .dial-needle {
            position: absolute;
            width: 3px;
            height: 50%;
            background: var(--primary-color);
            top: 0;
            left: 50%;
            transform-origin: bottom center;
            transform: translateX(-50%);
            border-radius: 3px;
            pointer-events: none;
            z-index: 10;
            box-shadow: 0 0 20px rgba(var(--primary-color-rgb), 0.4);
        }

        .dial-needle::after {
            content: '';
            position: absolute;
            bottom: -6px;
            left: 50%;
            transform: translateX(-50%);
            width: 12px;
            height: 12px;
            background: var(--primary-color);
            border-radius: 50%;
            box-shadow: 0 0 20px rgba(var(--primary-color-rgb), 0.6);
        }

        .dial-value {
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            font-size: min(12vw, 4.5rem);
            font-weight: 700;
            color: var(--primary-color);
            pointer-events: none;
            z-index: 10;
            text-shadow: 0 0 20px rgba(var(--primary-color-rgb), 0.4);
            font-family: 'Inter', -apple-system, BlinkMacSystemFont, sans-serif;
            letter-spacing: -1px;
            text-align: center;
        }

        .dial-markers {
            position: absolute;
            width: 100%;
            height: 100%;
            top: 0;
            left: 0;
            pointer-events: none;
        }

        .dial-marker {
            position: absolute;
            width: 2px;
            height: 12px;
            background: var(--primary-color);
            transform-origin: center bottom;
            box-shadow: 0 0 10px rgba(var(--primary-color-rgb), 0.3);
        }

        .dial-marker-label {
            position: absolute;
            color: var(--primary-color);
            font-size: 16px;
            font-weight: 600;
            white-space: nowrap;
            text-align: center;
            pointer-events: none;
            text-shadow: 0 0 10px rgba(var(--primary-color-rgb), 0.4);
            font-family: 'Inter', -apple-system, BlinkMacSystemFont, sans-serif;
        }

        @media (max-width: 768px) {
            .dial-container {
                width: 280px;
                height: 280px;
            }
            
            .dial-marker-label {
                font-size: 16px;
            }
            
            .dial-value {
                font-size: 3rem;
            }
        }

        .interest-input {
            width: 300px;
            max-width: 100%;
            padding: 15px;
            margin: 20px auto;
            border: 2px solid var(--primary-color);
            border-radius: 12px;
            font-size: min(4vw, 16px);
            background: var(--secondary-bg);
            color: var(--primary-color);
            transition: all 0.3s ease;
            display: block;
            text-align: center;
            box-sizing: border-box;
        }

        .interest-input::placeholder {
            color: rgba(29, 185, 84, 0.6);
        }

        .submit-btn {
            width: 300px;
            max-width: 100%;
            padding: 15px 0;
            background: var(--primary-color);
            color: var(--bg-color);
            border: none;
            border-radius: 30px;
            font-size: 18px;
            font-weight: bold;
            cursor: pointer;
            transition: background-color 0.3s ease;
            text-transform: uppercase;
            letter-spacing: 1px;
            margin-top: 10px;
            box-shadow: 0 4px 10px rgba(var(--primary-color-rgb), 0.3);
            box-sizing: border-box;
            display: flex;
            justify-content: center;
            align-items: center;
        }

        .submit-btn:hover {
            background-color: #2ed672;
        }

        .submit-btn:disabled {
            background: #666;
            cursor: not-allowed;
        }

        .error-message {
            color: var(--primary-color);
            margin: 10px auto;
            padding: 10px;
            border-radius: 8px;
            background: var(--error-bg);
            display: none;
            text-align: center;
            max-width: 300px;
            width: 100%;
            box-sizing: border-box;
            font-size: 14px;
        }

        .loading-spinner {
            display: none;
            width: 24px;
            height: 24px;
            border: 3px solid var(--secondary-bg);
            border-top: 3px solid var(--primary-color);
            border-radius: 50%;
            margin-left: 10px;
            animation: spin 1s linear infinite;
        }

        @keyframes spin {
            0% { transform: rotate(0deg); }
            100% { transform: rotate(360deg); }
        }

        .video-container {
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background-color: rgba(0, 0, 0, 0.9);
            z-index: 1000;
            display: none;
            flex-direction: column;
            justify-content: center;
            align-items: center;
            transition: transform 0.3s ease-out;
        }

        /* Animation for video end (TikTok-style) */
        @keyframes slideOut {
            0% {
                transform: translateX(0);
                opacity: 1;
            }
            100% {
                transform: translateX(-100%);
                opacity: 0;
            }
        }

        .video-end-animation {
            animation: slideOut 0.5s ease-out forwards;
        }

        #videoPlayer {
            width: 100%;
            height: 100%;
            border: none;
            background: #000;
        }

        .swipe-indicator {
            display: none; /* Hide the swipe indicator completely */
        }

        .swipe-indicator svg {
            margin-left: 8px;
        }

        .next-btn {
            position: absolute;
            bottom: 70px;
            right: 20px;
            background: var(--primary-color);
            color: white;
            width: 50px;
            height: 50px;
            border-radius: 50%;
            display: flex;
            align-items: center;
            justify-content: center;
            box-shadow: 0 4px 10px rgba(0,0,0,0.3);
            z-index: 2001;
            /* iOS improvements */
            -webkit-tap-highlight-color: rgba(0,0,0,0);
            touch-action: manipulation;
            cursor: pointer;
        }

        .close-btn {
            position: absolute;
            bottom: 130px;
            right: 20px;
            background: rgba(0,0,0,0.5);
            color: white;
            width: 50px;
            height: 50px;
            border-radius: 50%;
            display: flex;
            align-items: center;
            justify-content: center;
            z-index: 2010; /* Increased z-index to ensure it's above other elements */
            cursor: pointer; /* Add cursor pointer to indicate it's clickable */
            /* iOS improvements */
            -webkit-tap-highlight-color: rgba(0,0,0,0);
            touch-action: manipulation;
        }

        .api-key-modal {
            display: none;
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: rgba(0, 0, 0, 0.8);
            justify-content: center;
            align-items: center;
            z-index: 1000;
        }

        .api-key-form {
            background: var(--secondary-bg);
            padding: 30px;
            border-radius: 15px;
            width: 90%;
            max-width: 500px;
        }

        .api-key-input {
            width: 100%;
            padding: 12px;
            margin: 10px 0;
            border: 1px solid var(--primary-color);
            border-radius: 8px;
            background: var(--bg-color);
            color: var(--text-color);
        }

        label {
            display: block;
            text-align: center;
            margin-bottom: 15px;
            color: var(--primary-color);
            font-size: min(5vw, 1.2rem);
            font-weight: 500;
        }

        .test-mode {
            display: none;
        }

        .time-up-message {
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: rgba(0, 0, 0, 0.95);
            color: var(--primary-color);
            display: none;
            justify-content: center;
            align-items: center;
            z-index: 2002;
            font-size: min(15vw, 5rem);
            font-weight: 800;
            text-align: center;
            text-transform: uppercase;
            letter-spacing: 2px;
            box-shadow: 0 0 50px rgba(var(--primary-color-rgb), 0.5);
        }

        .form-container {
            display: flex;
            flex-direction: column;
            align-items: center;
            width: 300px;
            max-width: 100%;
            margin: 0 auto;
        }
    </style>
</head>
<body>
    <div class="progress-container">
        <div class="progress-bar"></div>
    </div>

    <div class="container">
        <h1>Killtime</h1>
        
        <div class="dial-container">
            <div class="dial">
                <div class="dial-fill"></div>
                <div class="dial-markers"></div>
                <div class="dial-needle"></div>
                <div class="dial-value">2:00</div>
            </div>
        </div>
        
        <div class="form-container">
            <label for="interest-input">What are you interested in watching?</label>
            <input type="text" id="interest-input" name="interest" class="interest-input" placeholder="Enter your interests (e.g., dogs, cooking, science)" value="dogs">
            <div class="error-message" role="alert"></div>
            <button class="submit-btn" type="button">
                Find Perfect Video
                <div class="loading-spinner"></div>
            </button>
        </div>
    </div>

    <div class="video-container">
        <div class="close-btn" aria-label="Close video">✕</div>
        <iframe id="videoPlayer" frameborder="0" allowfullscreen allow="autoplay; encrypted-media" playsinline webkit-playsinline title="YouTube video player"></iframe>
        <div class="next-btn" aria-label="Next video">
            <svg width="24" height="24" viewBox="0 0 24 24" fill="none" xmlns="http://www.w3.org/2000/svg" aria-hidden="true">
                <path d="M5 12H19" stroke="white" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"/>
                <path d="M12 5L19 12L12 19" stroke="white" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"/>
            </svg>
        </div>
    </div>

    <div class="api-key-modal">
        <div class="api-key-form">
            <h2>API Configuration</h2>
            <form id="api-key-form">
                <label for="youtubeKey">YouTube API Key</label>
                <input type="password" id="youtubeKey" name="youtubeKey" class="api-key-input" placeholder="Enter your YouTube API Key">
                <button type="button" id="save-keys-btn" class="submit-btn">Save Key</button>
            </form>
        </div>
    </div>

    <div class="test-mode">Test Mode</div>

    <div class="time-up-message">Time's up!</div>

    <script>
        // Global variables to track progress
        let dialValue = 120; // 2 minutes in seconds (default)
        const dial = document.querySelector('.dial');
        const dialNeedle = document.querySelector('.dial-needle');
        const dialDisplay = document.querySelector('.dial-value');
        const dialFill = document.querySelector('.dial-fill');
        const interestInput = document.getElementById('interest-input');
        const submitBtn = document.querySelector('.submit-btn');
        const videoContainer = document.querySelector('.video-container');
        const videoPlayer = document.querySelector('#videoPlayer');
        const progressContainer = document.querySelector('.progress-container');
        const progressBar = document.querySelector('.progress-bar');
        const closeBtn = document.querySelector('.close-btn');
        const nextBtn = document.querySelector('.next-btn');
        let isRotating = false;
        let startAngle = 0;
        let currentInterest = '';
        let progressInterval;
        let touchStartY = 0;
        let touchEndY = 0;
        let swipeTimeout;
        let elapsedTime = 0; // Track elapsed time globally
        
        // API key placeholder - will be loaded from server or environment
        // DO NOT replace this with your actual API key if pushing to GitHub
        const DEFAULT_YOUTUBE_API_KEY = "REPLACE_WITH_YOUR_YOUTUBE_API_KEY";
        
        // Function to fetch API key from server (if available)
        async function fetchApiKey() {
            try {
                const response = await fetch('/api/youtube-key');
                if (response.ok) {
                    const data = await response.json();
                    if (data.key) {
                        setLocalStorageWithFallback('youtubeKey', data.key);
                        return true;
                    }
                }
                return false;
            } catch (error) {
                console.error('Error fetching API key:', error);
                return false;
            }
        }
        
        // Try to fetch API key on page load
        document.addEventListener('DOMContentLoaded', async function() {
            // Only try to fetch from server if we don't have a valid key already
            const storedKey = getStoredValue('youtubeKey', '');
            if (!storedKey || storedKey === "REPLACE_WITH_YOUR_YOUTUBE_API_KEY") {
                await fetchApiKey();
            }
            
            // Initialize dial
            initializeDial();
            
            // Add event listeners for window resize and orientation change
            window.addEventListener('resize', function() {
                createDialMarkers();
                // Update viewport height on resize
                const vh = window.innerHeight * 0.01;
                document.documentElement.style.setProperty('--vh', `${vh}px`);
            });
        });

        // Function to create dial markers
        function createDialMarkers() {
            const dialMarkers = document.querySelector('.dial-markers');
            dialMarkers.innerHTML = '';
            
            const dialSize = dial.offsetWidth;
            const center = dialSize / 2;
            const borderWidth = 2;
            
            // Create markers for 5, 10, and 15 minutes
            for (let i = 5; i <= 15; i += 5) {
                const minutes = i;
                const angle = (minutes / 15) * 360 - 90;
                const radians = (angle * Math.PI) / 180;
                
                // Create marker line
                const marker = document.createElement('div');
                marker.className = 'dial-marker';
                
                const markerDistance = center - borderWidth;
                const markerX = center + Math.cos(radians) * markerDistance;
                const markerY = center + Math.sin(radians) * markerDistance;
                
                marker.style.left = `${markerX}px`;
                marker.style.top = `${markerY}px`;
                marker.style.transform = `rotate(${angle + 90}deg)`;
                
                // Create label
                const label = document.createElement('div');
                label.className = 'dial-marker-label';
                label.textContent = minutes;
                
                const labelDistance = center * 1.15;
                const labelX = center + Math.cos(radians) * labelDistance;
                const labelY = center + Math.sin(radians) * labelDistance;
                
                label.style.left = `${labelX}px`;
                label.style.top = `${labelY}px`;
                label.style.transform = 'translate(-50%, -50%)';
                
                if (minutes === 15) {
                    label.style.fontSize = '18px';
                    label.style.fontWeight = '700';
                }
                
                dialMarkers.appendChild(marker);
                dialMarkers.appendChild(label);
            }
        }

        // Function to update the dial display (time text)
        function updateDialDisplay() {
            const minutes = Math.floor(dialValue / 60);
            const seconds = dialValue % 60;
            // Always show two digits for minutes and seconds
            dialDisplay.textContent = `${minutes}:${seconds.toString().padStart(2, '0')}`;
        }

        // Function to update the dial needle position
        function updateDialNeedle() {
            const degrees = (dialValue / 900) * 360;
            dialNeedle.style.transform = `translateX(-50%) rotate(${degrees}deg)`;
        }

        // Function to update the dial fill
        function updateDialFill() {
            const fillPercentage = dialValue / 900; // 900 seconds = 15 minutes
            const angle = fillPercentage * 360;
            
            if (fillPercentage <= 0) {
                dialFill.style.background = 'transparent';
            } else if (fillPercentage >= 1) {
                dialFill.style.background = 'rgba(var(--primary-color-rgb), 0.15)';
            } else {
                // Use conic-gradient for the fill, starting from the top (0deg)
                dialFill.style.background = `conic-gradient(
                    from 0deg at 50% 50%,
                    rgba(var(--primary-color-rgb), 0.15) 0deg ${angle}deg,
                    transparent ${angle}deg 360deg
                )`;
            }
        }

        // Initialize the dial
        function initializeDial() {
            dialValue = 120; // 2 minutes default
            updateDialDisplay();
            updateDialNeedle();
            updateDialFill();
            createDialMarkers();
        }

        // Handle dial rotation for mouse events
        dial.addEventListener('mousedown', function(e) {
            e.preventDefault();
            isRotating = true;
            const rect = dial.getBoundingClientRect();
            const center = {
                x: rect.left + rect.width / 2,
                y: rect.top + rect.height / 2
            };
            startAngle = Math.atan2(e.clientY - center.y, e.clientX - center.x);
        });

        document.addEventListener('mousemove', function(e) {
            if (!isRotating) return;
            
            const rect = dial.getBoundingClientRect();
            const center = {
                x: rect.left + rect.width / 2,
                y: rect.top + rect.height / 2
            };
            
            const currentAngle = Math.atan2(e.clientY - center.y, e.clientX - center.x);
            let angleDiff = currentAngle - startAngle;
            
            // Convert to seconds (15 minutes = 900 seconds = 2π radians)
            const secondsChange = angleDiff * (900 / (2 * Math.PI));
            
            // Update the dial value
            let newValue = dialValue + secondsChange;
            newValue = Math.max(0, Math.min(900, Math.round(newValue / 5) * 5));
            
            if (newValue !== dialValue) {
                dialValue = newValue;
                updateDialDisplay();
                updateDialNeedle();
                updateDialFill();
            }
            
            startAngle = currentAngle;
        });

        document.addEventListener('mouseup', function() {
            isRotating = false;
        });

        // Handle dial rotation for touch events
        dial.addEventListener('touchstart', function(e) {
            e.preventDefault();
            isRotating = true;
            const rect = dial.getBoundingClientRect();
            const center = {
                x: rect.left + rect.width / 2,
                y: rect.top + rect.height / 2
            };
            const touch = e.touches[0];
            startAngle = Math.atan2(touch.clientY - center.y, touch.clientX - center.x);
        });

        dial.addEventListener('touchmove', function(e) {
            if (!isRotating) return;
            
            const rect = dial.getBoundingClientRect();
            const center = {
                x: rect.left + rect.width / 2,
                y: rect.top + rect.height / 2
            };
            
            const touch = e.touches[0];
            const currentAngle = Math.atan2(touch.clientY - center.y, touch.clientX - center.x);
            let angleDiff = currentAngle - startAngle;
            
            // Convert to seconds (15 minutes = 900 seconds = 2π radians)
            const secondsChange = angleDiff * (900 / (2 * Math.PI));
            
            // Update the dial value
            let newValue = dialValue + secondsChange;
            newValue = Math.max(0, Math.min(900, Math.round(newValue / 5) * 5));
            
            if (newValue !== dialValue) {
                dialValue = newValue;
                updateDialDisplay();
                updateDialNeedle();
                updateDialFill();
            }
            
            startAngle = currentAngle;
            e.preventDefault();
        });

        dial.addEventListener('touchend', function() {
            isRotating = false;
        });

        // Store keys with SameSite attribute
        function setLocalStorageWithFallback(key, value) {
            try {
                localStorage.setItem(key, value);
            } catch (e) {
                console.error('Error saving to localStorage:', e);
                // Fallback to cookies with SameSite attribute
                document.cookie = `${key}=${value}; SameSite=Lax; Secure; max-age=31536000; path=/`;
            }
        }

        function getStoredValue(key, defaultValue) {
            try {
                const localValue = localStorage.getItem(key);
                if (localValue) return localValue;
                
                // Try to get from cookies if localStorage fails
                const cookies = document.cookie.split(';');
                for (let i = 0; i < cookies.length; i++) {
                    const cookie = cookies[i].trim();
                    if (cookie.startsWith(key + '=')) {
                        return cookie.substring(key.length + 1);
                    }
                }
                return defaultValue;
            } catch (e) {
                console.error('Error accessing storage:', e);
                return defaultValue;
            }
        }

        // Check for API keys - only show modal if YouTube key is not set and not using default key
        if ((!getStoredValue('youtubeKey', '') || getStoredValue('youtubeKey', '') === "REPLACE_WITH_YOUR_YOUTUBE_API_KEY") && 
            DEFAULT_YOUTUBE_API_KEY === "REPLACE_WITH_YOUR_YOUTUBE_API_KEY") {
            document.querySelector('.api-key-modal').style.display = 'flex';
        } else {
            // If we have a default key, store it
            if (DEFAULT_YOUTUBE_API_KEY !== "REPLACE_WITH_YOUR_YOUTUBE_API_KEY" && 
                (!getStoredValue('youtubeKey', '') || getStoredValue('youtubeKey', '') === "REPLACE_WITH_YOUR_YOUTUBE_API_KEY")) {
                setLocalStorageWithFallback('youtubeKey', DEFAULT_YOUTUBE_API_KEY);
            }
        }

        function saveApiKeys() {
            const youtubeKey = document.getElementById('youtubeKey').value;
            
            if (youtubeKey) {
                setLocalStorageWithFallback('youtubeKey', youtubeKey);
                document.querySelector('.api-key-modal').style.display = 'none';
            } else {
                alert('Please enter a YouTube API key');
            }
        }

        // Connect the save button to the saveApiKeys function
        document.getElementById('save-keys-btn').addEventListener('click', saveApiKeys);

        // Improved TikTok-style swipe handling
        let swipeStartTime = 0;
        let swipeThreshold = 80; // Pixels to trigger a swipe
        let velocityThreshold = 0.3; // Pixels per millisecond

        // Add these iOS compatibility improvements right after the videoContainer event listeners
        videoPlayer.setAttribute('playsinline', '');
        videoPlayer.setAttribute('webkit-playsinline', '');
        videoPlayer.setAttribute('muted', 'muted');

        // Update the video container touch handling for better iOS compatibility
        videoContainer.addEventListener('touchstart', function(e) {
            console.log('Touch start detected');
            touchStartY = e.changedTouches[0].screenY;
            swipeStartTime = Date.now();
        }, { passive: true });

        videoContainer.addEventListener('touchmove', function(e) {
            const touch = e.changedTouches[0];
            const deltaY = touchStartY - touch.screenY;
            
            console.log('Touch move detected, deltaY:', deltaY);
            
            // Make swipe detection extremely sensitive for iOS
            if (Math.abs(deltaY) > 2) {  // Extremely low threshold
                const translateY = Math.min(deltaY * 0.8, window.innerHeight * 0.3);
                videoContainer.style.transform = `translateY(-${translateY}px)`;
                
                // Only prevent default if we're actually handling the swipe
                if (Math.abs(deltaY) > 5) {
                    e.preventDefault();
                }
            }
        }, { passive: false });
        
        videoContainer.addEventListener('touchend', function(e) {
            console.log('Touch end detected');
            touchEndY = e.changedTouches[0].screenY;
            const swipeDistance = touchStartY - touchEndY;
            const swipeTime = Date.now() - swipeStartTime;
            const swipeVelocity = Math.abs(swipeDistance) / swipeTime;
            
            // Make swipe detection extremely sensitive on iOS
            const isIOS = /iPad|iPhone|iPod/.test(navigator.userAgent) && !window.MSStream;
            const swipeThresholdForDevice = isIOS ? 10 : swipeThreshold; // Even lower threshold
            const velocityThresholdForDevice = isIOS ? 0.05 : velocityThreshold; // Lower velocity threshold
            
            const isValidSwipe = swipeDistance > swipeThresholdForDevice || 
                               (swipeDistance > 5 && swipeVelocity > velocityThresholdForDevice);
            
            console.log('Swipe data:', {
                distance: swipeDistance,
                time: swipeTime,
                velocity: swipeVelocity,
                isValid: isValidSwipe,
                isIOS: isIOS
            });
            
            if (isValidSwipe) {
                console.log('Valid swipe detected, loading next video');
                // TikTok-style animation - slide up and out
                videoContainer.style.transition = 'transform 0.4s cubic-bezier(0.19, 1, 0.22, 1)';
                videoContainer.style.transform = 'translateY(-100%)';
                
                // After animation completes, reset position and get next video
                setTimeout(() => {
                    videoContainer.style.transition = 'none';
                    videoContainer.style.transform = 'translateY(0)';
                    if (currentInterest) {
                        fetchVideo(currentInterest, false);
                    }
                }, 400);
            } else {
                // Snap back if not a valid swipe
                videoContainer.style.transition = 'transform 0.2s ease-out';
                videoContainer.style.transform = 'translateY(0)';
            }
        }, { passive: true });

        // Prevent default on touchmove for the entire document to disable scrolling
        document.addEventListener('touchmove', function(e) {
            // Allow scrolling only within elements that need it
            const isScrollableElement = e.target.closest('.container');
            if (!isScrollableElement) {
                e.preventDefault();
            }
        }, { passive: false });

        // Close video button
        closeBtn.addEventListener('click', function() {
            videoContainer.style.display = 'none';
            progressContainer.style.display = 'none';
            clearInterval(progressInterval);
            videoPlayer.src = ''; // Clear the iframe source when closing
            
            // Reset progress bar height for next time
            progressContainer.style.height = '24px';
            const progressTime = document.querySelector('.progress-time');
            if (progressTime) {
                progressTime.style.opacity = '1';
            }
            
            // If there's a YouTube player instance, destroy it
            if (window.player && typeof window.player.destroy === 'function') {
                try {
                    window.player.destroy();
                } catch (e) {
                    console.error('Error destroying player:', e);
                }
            }
        });

        // Add touchend event for better iOS button response
        closeBtn.addEventListener('touchend', function(e) {
            e.preventDefault();
            closeBtn.click();
        });

        // Next video button
        nextBtn.addEventListener('click', function() {
            console.log('Next button clicked');
            // Clear the current video first
            videoPlayer.src = '';
            // Add a small delay before loading the next video
            setTimeout(function() {
                console.log('Loading next video');
                if (currentInterest) {
                    // Don't reset progress bar when getting next video
                    fetchVideo(currentInterest, false);
                }
            }, 100);
        });
        
        // Add touchend event for better iOS button response
        nextBtn.addEventListener('touchend', function(e) {
            console.log('Next button touched');
            e.preventDefault();
            // Clear the current video first
            videoPlayer.src = '';
            // Add a small delay before loading the next video
            setTimeout(function() {
                console.log('Loading next video after touch');
                if (currentInterest) {
                    // Don't reset progress bar when getting next video
                    fetchVideo(currentInterest, false);
                }
            }, 100);
        });

        // Function to handle orientation changes specifically for iOS
        function handleIOSOrientationChange() {
            // Force redraw by temporarily changing a style property
            document.body.style.display = 'none';
            // Trigger reflow
            void document.body.offsetHeight;
            document.body.style.display = '';
            
            // Recreate dial markers after a short delay to ensure dimensions are updated
            setTimeout(createDialMarkers, 300);
            
            // Update viewport height for iOS
            const vh = window.innerHeight * 0.01;
            document.documentElement.style.setProperty('--vh', `${vh}px`);
        }

        // Add event listeners for orientation changes
        window.addEventListener('orientationchange', handleIOSOrientationChange);

        // Set initial viewport height
        document.addEventListener('DOMContentLoaded', function() {
            // Set initial viewport height for iOS
            const vh = window.innerHeight * 0.01;
            document.documentElement.style.setProperty('--vh', `${vh}px`);
            
            // Initialize dial
            initializeDial();
            
            // Add event listeners for window resize and orientation change
            window.addEventListener('resize', function() {
                createDialMarkers();
                // Update viewport height on resize
                const vh = window.innerHeight * 0.01;
                document.documentElement.style.setProperty('--vh', `${vh}px`);
            });
        });

        function startProgressBar() {
            elapsedTime = 0; // Reset elapsed time when starting fresh
            progressBar.style.width = '0%';
            progressContainer.style.display = 'block';
            progressContainer.style.opacity = '1';
            
            // Create or update the time display
            let progressTime = document.querySelector('.progress-time');
            if (!progressTime) {
                progressTime = document.createElement('div');
                progressTime.className = 'progress-time';
                progressContainer.appendChild(progressTime);
            }
            
            // Keep progress bar large and visible
            progressContainer.style.height = '24px';
            progressTime.style.opacity = '1';
            
            // Format time remaining
            const formatTimeRemaining = (seconds) => {
                const mins = Math.floor(seconds / 60);
                const secs = seconds % 60;
                return `${mins}:${secs.toString().padStart(2, '0')}`;
            };
            
            // Update time display
            progressTime.textContent = formatTimeRemaining(dialValue - elapsedTime);
            
            clearInterval(progressInterval);
            progressInterval = setInterval(() => {
                elapsedTime++;
                const percentage = (elapsedTime / dialValue) * 100;
                progressBar.style.width = `${percentage}%`;
                
                // Update time remaining
                progressTime.textContent = formatTimeRemaining(dialValue - elapsedTime);
                
                if (elapsedTime >= dialValue) {
                    clearInterval(progressInterval);
                    showTimeUpMessage();
                }
            }, 1000);
        }

        function continueProgressBar() {
            // Don't reset elapsed time, just continue from where we left off
            progressContainer.style.display = 'block';
            progressContainer.style.opacity = '1';
            
            // Create or update the time display
            let progressTime = document.querySelector('.progress-time');
            if (!progressTime) {
                progressTime = document.createElement('div');
                progressTime.className = 'progress-time';
                progressContainer.appendChild(progressTime);
            }
            
            // Keep progress bar large and visible
            progressContainer.style.height = '24px';
            progressTime.style.opacity = '1';
            
            // Format time remaining
            const formatTimeRemaining = (seconds) => {
                const mins = Math.floor(seconds / 60);
                const secs = seconds % 60;
                return `${mins}:${secs.toString().padStart(2, '0')}`;
            };
            
            // Update time display
            progressTime.textContent = formatTimeRemaining(dialValue - elapsedTime);
            
            clearInterval(progressInterval);
            progressInterval = setInterval(() => {
                elapsedTime++;
                const percentage = (elapsedTime / dialValue) * 100;
                progressBar.style.width = `${percentage}%`;
                
                // Update time remaining
                progressTime.textContent = formatTimeRemaining(dialValue - elapsedTime);
                
                if (elapsedTime >= dialValue) {
                    clearInterval(progressInterval);
                    showTimeUpMessage();
                }
            }, 1000);
        }

        function showTimeUpMessage() {
            const timeUpMessage = document.querySelector('.time-up-message');
            timeUpMessage.style.display = 'flex'; // Changed to flex for centering
            timeUpMessage.textContent = dialValue === 0 ? "TIME TO GO" : "TIME TO GO";
            
            // Hide the message after 3 seconds and close the video
            setTimeout(() => {
                timeUpMessage.style.display = 'none';
                closeBtn.click();
            }, 3000);
        }

        function getNextVideo() {
            if (currentInterest) {
                // Don't reset progress bar when getting next video
                fetchVideo(currentInterest, false);
            }
        }

        async function fetchVideo(interest, resetProgress = true) {
            const errorMessage = document.querySelector('.error-message');
            const loadingSpinner = document.querySelector('.loading-spinner');
            
            try {
                submitBtn.disabled = true;
                loadingSpinner.style.display = 'inline-block';
                
                let youtubeKey = getStoredValue('youtubeKey', DEFAULT_YOUTUBE_API_KEY);
                
                if (!youtubeKey || youtubeKey === "REPLACE_WITH_YOUR_YOUTUBE_API_KEY") {
                    throw new Error('YouTube API key not found. Please configure your API key.');
                }
                
                // STANDALONE MODE - No server required
                // 1. First, create a search query based on the interest
                const searchQuery = await createSearchQuery(interest);
                
                // 2. Then search YouTube directly
                const video = await searchYouTube(searchQuery, youtubeKey, dialValue);
                
                if (video && video.id) {
                    // First show black screen and progress bar
                    videoContainer.style.display = 'flex';
                    
                    // Start or continue progress bar immediately
                    if (resetProgress) {
                        startProgressBar();
                    } else {
                        continueProgressBar();
                    }
                    
                    // Then load the video after a short delay
                    setTimeout(() => {
                        try {
                            // Check if we're on iOS
                            const isIOS = /iPad|iPhone|iPod/.test(navigator.userAgent) && !window.MSStream;
                            
                            if (isIOS) {
                                // iOS-specific approach - simpler is better for iOS
                                console.log('Using iOS-specific video loading approach');
                                
                                // Clear any existing content
                                videoPlayer.src = '';
                                
                                // Set attributes first - these are critical for iOS
                                videoPlayer.setAttribute('playsinline', '');
                                videoPlayer.setAttribute('webkit-playsinline', '');
                                videoPlayer.setAttribute('allow', 'autoplay; encrypted-media');
                                
                                // For iOS, we need to use a direct approach
                                const videoUrl = `https://www.youtube.com/embed/${video.id}?autoplay=1&playsinline=1&mute=0&controls=1&rel=0&showinfo=0&modestbranding=1&iv_load_policy=3&fs=0`;
                                
                                // Set the source with all required parameters
                                videoPlayer.src = videoUrl;
                                
                                // Force reload the iframe
                                setTimeout(() => {
                                    try {
                                        // Try to reload the iframe
                                        const currentSrc = videoPlayer.src;
                                        videoPlayer.src = '';
                                        setTimeout(() => {
                                            // Add unmute parameter explicitly
                                            videoPlayer.src = currentSrc.replace('mute=0', 'mute=0');
                                            
                                            // Add a click handler to unmute after user interaction
                                            const unmuteHandler = function() {
                                                try {
                                                    // Try to access the iframe and unmute
                                                    const iframe = document.getElementById('videoPlayer');
                                                    if (iframe) {
                                                        // Send a postMessage to unmute
                                                        iframe.contentWindow.postMessage('{"event":"command","func":"unMute","args":""}', '*');
                                                    }
                                                } catch (e) {
                                                    console.log('Error in unmute handler:', e);
                                                }
                                                // Remove this handler after first click
                                                document.removeEventListener('click', unmuteHandler);
                                                document.removeEventListener('touchend', unmuteHandler);
                                            };
                                            
                                            // Add listeners for both click and touch events
                                            document.addEventListener('click', unmuteHandler);
                                            document.addEventListener('touchend', unmuteHandler);
                                        }, 50);
                                    } catch (e) {
                                        console.log('Error reloading iframe:', e);
                                    }
                                }, 100);
                            } else {
                                // Standard approach for other platforms
                                videoPlayer.src = `https://www.youtube.com/embed/${video.id}?autoplay=1&enablejsapi=1&origin=${window.location.origin}&rel=0&playsinline=1&mute=1&controls=1`;
                            }
                            
                            errorMessage.style.display = 'none';
                            
                            // Clear any existing timeout
                            clearTimeout(swipeTimeout);
                            
                            // Set up event listener for video end
                            setupVideoEndListener(video.id);
                            
                            // Add manual check for video end
                            setTimeout(addVideoEndCheck, 2000);
                        } catch (error) {
                            console.error('Error loading video:', error);
                            errorMessage.textContent = 'Error loading video. Please try again.';
                            errorMessage.style.display = 'block';
                        }
                    }, 500);
                } else {
                    throw new Error('No suitable videos found. Please try a different interest.');
                }
            } catch (error) {
                console.error('Error:', error);
                errorMessage.textContent = error.message || 'An error occurred. Please try again.';
                errorMessage.style.display = 'block';
                videoContainer.style.display = 'none';
                // Don't hide progress container when there's an error
            } finally {
                submitBtn.disabled = false;
                loadingSpinner.style.display = 'none';
            }
        }
        
        // Create a search query based on the interest
        async function createSearchQuery(interest) {
            // For simplicity, we'll just add some keywords to make the search more specific
            const minutes = Math.floor(dialValue / 60);
            
            // Check if device is in portrait mode
            const isPortrait = window.innerHeight > window.innerWidth;
            
            // Keywords for regular videos
            const regularKeywords = [
                'guide', 'tutorial', 'how to', 'explanation', 'tips', 
                'facts about', 'information', 'learn about'
            ];
            
            // Keywords for vertical/short videos
            const verticalKeywords = [
                'shorts', 'tiktok', 'vertical video', 'short form', 'reels'
            ];
            
            // Choose keywords based on orientation
            const keywordsArray = isPortrait ? verticalKeywords : regularKeywords;
            
            // Pick a random keyword to combine with the interest
            const randomKeyword = keywordsArray[Math.floor(Math.random() * keywordsArray.length)];
            
            // Create query with minutes but without explicitly mentioning "english"
            // The relevanceLanguage parameter in the API call will handle language filtering
            let query = `${interest} ${randomKeyword}`;
            
            // Add duration hint for regular videos, but not for shorts
            if (!isPortrait) {
                query += ` ${minutes} minutes`;
            }
            
            console.log('Search query:', query, 'isPortrait:', isPortrait);
            
            return query;
        }
        
        // Search YouTube directly
        async function searchYouTube(query, apiKey, targetDuration) {
            try {
                // Check if device is in portrait mode
                const isPortrait = window.innerHeight > window.innerWidth;
                
                // First, search for videos matching the query
                let searchUrl = `https://www.googleapis.com/youtube/v3/search?part=snippet&q=${encodeURIComponent(query)}&type=video&videoEmbeddable=true&videoSyndicated=true&maxResults=20&relevanceLanguage=en&key=${apiKey}`;
                
                // For portrait mode, prioritize short videos
                if (isPortrait) {
                    // Add videoDuration=short parameter to find shorter videos
                    searchUrl += '&videoDuration=short';
                }
                
                const searchResponse = await fetch(searchUrl);
                const searchData = await searchResponse.json();
                
                if (!searchResponse.ok) {
                    // Check if we hit the quota limit
                    if (searchData.error && searchData.error.message && 
                        searchData.error.message.includes('quota')) {
                        console.log('YouTube API quota exceeded, using fallback method');
                        return await fallbackVideoSearch(query, isPortrait);
                    }
                    throw new Error(searchData.error?.message || 'YouTube API error');
                }
                
                if (!searchData.items || searchData.items.length === 0) {
                    throw new Error('No videos found matching your interest. Please try a different topic.');
                }
                
                // Get video IDs from search results
                const videoIds = searchData.items.map(item => item.id.videoId).join(',');
                
                // Get detailed information about these videos
                const detailsUrl = `https://www.googleapis.com/youtube/v3/videos?part=contentDetails,statistics,status,snippet&id=${videoIds}&key=${apiKey}`;
                const detailsResponse = await fetch(detailsUrl);
                const detailsData = await detailsResponse.json();
                
                if (!detailsResponse.ok) {
                    // Check if we hit the quota limit
                    if (detailsData.error && detailsData.error.message && 
                        detailsData.error.message.includes('quota')) {
                        console.log('YouTube API quota exceeded, using fallback method');
                        return await fallbackVideoSearch(query, isPortrait);
                    }
                    throw new Error(detailsData.error?.message || 'YouTube API error');
                }
                
                // Combine search results with video details and filter for embeddable videos
                const videos = [];
                
                searchData.items.forEach(searchItem => {
                    const videoDetails = detailsData.items.find(item => item.id === searchItem.id.videoId);
                    
                    if (videoDetails && videoDetails.status.embeddable !== false) {
                        const duration = parseDuration(videoDetails.contentDetails.duration);
                        
                        // Different duration handling based on orientation
                        if (isPortrait) {
                            // For portrait mode, prefer shorter videos (under 60 seconds)
                            if (duration > 60) {
                                return;
                            }
                        } else {
                            // For landscape mode, respect the selected time
                            if (duration > targetDuration) {
                                return;
                            }
                        }
                        
                        // Check if video is in English (either by snippet.defaultAudioLanguage or defaultLanguage)
                        // but don't filter out videos with no language specified
                        const videoLanguage = videoDetails.snippet.defaultAudioLanguage || videoDetails.snippet.defaultLanguage || '';
                        const isEnglish = !videoLanguage || videoLanguage.startsWith('en');
                        
                        // Skip non-English videos if we can detect the language
                        if (videoLanguage && !isEnglish) {
                            return;
                        }
                        
                        // Skip videos that are specifically about learning English language
                        const title = videoDetails.snippet.title.toLowerCase();
                        const description = videoDetails.snippet.description.toLowerCase();
                        if ((title.includes('learn english') || title.includes('english lesson') || 
                             title.includes('english class') || title.includes('english course')) &&
                            (description.includes('learn english') || description.includes('english lesson') || 
                             description.includes('english grammar') || description.includes('english vocabulary'))) {
                            return;
                        }
                        
                        const viewCount = parseInt(videoDetails.statistics.viewCount || '0');
                        
                        // Calculate relevance score based on duration match and view count
                        const durationDiff = Math.abs(duration - targetDuration);
                        const durationScore = Math.max(0, 1 - (durationDiff / targetDuration));
                        const viewScore = Math.min(1, Math.log10(viewCount + 1) / 7);
                        const relevanceScore = (durationScore * 0.7) + (viewScore * 0.3);
                        
                        videos.push({
                            id: searchItem.id.videoId,
                            title: searchItem.snippet.title,
                            channelTitle: searchItem.snippet.channelTitle,
                            duration: duration,
                            viewCount: viewCount,
                            relevanceScore: relevanceScore,
                            language: videoLanguage
                        });
                    }
                });
                
                if (videos.length === 0) {
                    throw new Error('No suitable videos found. Try a different interest or increase the time.');
                }
                
                // Sort by relevance score (highest first)
                videos.sort((a, b) => b.relevanceScore - a.relevanceScore);
                
                // Return the best match
                return videos[0];
            } catch (error) {
                console.error('YouTube search error:', error);
                throw error;
            }
        }
        
        // Parse YouTube duration format (PT1H30M15S) to seconds
        function parseDuration(duration) {
            const match = duration.match(/PT(\d+H)?(\d+M)?(\d+S)?/);
            if (!match) return 0; // Handle invalid duration format
            
            const hours = match[1] ? match[1].slice(0, -1) : '0';
            const minutes = match[2] ? match[2].slice(0, -1) : '0';
            const seconds = match[3] ? match[3].slice(0, -1) : '0';
            
            return (parseInt(hours) * 3600) + (parseInt(minutes) * 60) + parseInt(seconds);
        }

        // Function to set up event listener for video end
        function setupVideoEndListener(videoId) {
            try {
                // Create YouTube Player API script if it doesn't exist
                if (!window.YT) {
                    const tag = document.createElement('script');
                    tag.src = "https://www.youtube.com/iframe_api";
                    const firstScriptTag = document.getElementsByTagName('script')[0];
                    firstScriptTag.parentNode.insertBefore(tag, firstScriptTag);
                    
                    window.onYouTubeIframeAPIReady = function() {
                        createYTPlayer(videoId);
                    };
                } else if (window.YT && window.YT.Player) {
                    createYTPlayer(videoId);
                } else {
                    // If YT object exists but Player is not ready
                    setTimeout(() => {
                        if (window.YT && window.YT.Player) {
                            createYTPlayer(videoId);
                        } else {
                            setupVideoEndFallback();
                        }
                    }, 1000);
                }
            } catch (error) {
                console.error('Error setting up YouTube API:', error);
                // Fallback for when YouTube API fails
                setupVideoEndFallback();
            }
        }

        // Fallback method to handle video end when YouTube API fails
        function setupVideoEndFallback() {
            console.log('Using fallback method for video end detection');
            // Check video progress every second and compare with dialValue
            const checkVideoInterval = setInterval(() => {
                if (elapsedTime >= dialValue * 0.95) { // 95% of the way through
                    clearInterval(checkVideoInterval);
                    console.log('Video end detected by fallback method');
                    
                    // TikTok-style animation
                    videoContainer.style.transition = 'transform 0.4s cubic-bezier(0.19, 1, 0.22, 1)';
                    videoContainer.style.transform = 'translateY(-100%)';
                    
                    setTimeout(() => {
                        videoContainer.style.transition = 'none';
                        videoContainer.style.transform = 'translateY(0)';
                        getNextVideo();
                    }, 400);
                }
            }, 1000);
        }

        // Create YouTube player and set up event listeners
        function createYTPlayer(videoId) {
            console.log('Creating YouTube player for video ID:', videoId);
            
            if (window.player) {
                try {
                    window.player.destroy();
                } catch (e) {
                    console.error('Error destroying player:', e);
                }
            }
            
            try {
                // Store the iframe element
                const iframeElement = document.getElementById('videoPlayer');
                
                // If the iframe has been replaced with a div by the YouTube API
                if (iframeElement && iframeElement.tagName !== 'IFRAME') {
                    iframeElement.id = 'videoPlayer-container';
                    const newIframe = document.createElement('iframe');
                    newIframe.id = 'videoPlayer';
                    newIframe.frameBorder = '0';
                    newIframe.allowFullscreen = true;
                    newIframe.allow = 'autoplay; encrypted-media';
                    newIframe.title = 'YouTube video player';
                    // Add iOS-specific attributes
                    newIframe.setAttribute('playsinline', '');
                    newIframe.setAttribute('webkit-playsinline', '');
                    iframeElement.parentNode.replaceChild(newIframe, iframeElement);
                }
                
                // Define YT.PlayerState if it doesn't exist
                if (!window.YT) {
                    window.YT = {};
                }
                if (!window.YT.PlayerState) {
                    window.YT.PlayerState = {
                        ENDED: 0,
                        PLAYING: 1,
                        PAUSED: 2,
                        BUFFERING: 3,
                        CUED: 5
                    };
                }
                
                // Special handling for iOS
                const isIOS = /iPad|iPhone|iPod/.test(navigator.userAgent) && !window.MSStream;
                const playerVars = {
                    'autoplay': 1,
                    'playsinline': 1,
                    'controls': 1,
                    'rel': 0,
                    'fs': 0,
                    'modestbranding': 1,
                    'mute': 1, // Start muted for iOS autoplay
                    'origin': window.location.origin
                };
                
                window.player = new YT.Player('videoPlayer', {
                    videoId: videoId,
                    playerVars: playerVars,
                    events: {
                        'onReady': onPlayerReady,
                        'onStateChange': onPlayerStateChange,
                        'onError': onPlayerError
                    }
                });
            } catch (error) {
                console.error('Error creating YouTube player:', error);
                setupVideoEndFallback();
                
                // Direct iframe approach as fallback
                const iframeElement = document.getElementById('videoPlayer');
                if (iframeElement && iframeElement.tagName === 'IFRAME') {
                    iframeElement.src = `https://www.youtube.com/embed/${videoId}?autoplay=1&enablejsapi=1&origin=${window.location.origin}&rel=0&playsinline=1&mute=1&controls=1`;
                    // Add iOS-specific attributes directly
                    iframeElement.setAttribute('playsinline', '');
                    iframeElement.setAttribute('webkit-playsinline', '');
                }
            }
        }
        
        // When player is ready
        function onPlayerReady(event) {
            console.log('YouTube player ready');
            event.target.playVideo();
            
            // Unmute after a short delay (for iOS)
            setTimeout(() => {
                try {
                    event.target.unMute();
                    event.target.setVolume(100);
                } catch (e) {
                    console.error('Error unmuting:', e);
                }
            }, 1000);
        }

        // Handle player errors
        function onPlayerError(event) {
            console.error('YouTube player error:', event.data);
            // Try to get next video on error
            getNextVideo();
        }

        // Handle player state changes
        function onPlayerStateChange(event) {
            console.log('Player state changed to:', event.data);
            // When video ends (state = 0), play next video with TikTok animation
            if (event.data === 0 || (window.YT && event.data === YT.PlayerState.ENDED)) {
                console.log('Video ended, playing next video');
                
                // Small delay before getting next video to ensure clean transition
                setTimeout(() => {
                    getNextVideo();
                }, 300);
            }
        }

        // Function to manually check if video has ended
        function addVideoEndCheck() {
            console.log('Setting up manual video end check');
            let checkInterval;
            let startTime = Date.now();
            
            // Check every second if the video has ended or if we can't access it
            checkInterval = setInterval(() => {
                try {
                    const iframe = document.getElementById('videoPlayer');
                    if (!iframe) {
                        clearInterval(checkInterval);
                        return;
                    }
                    
                    // Try to access the video element inside the iframe
                    const iframeDoc = iframe.contentDocument || iframe.contentWindow.document;
                    const videoElement = iframeDoc.querySelector('video');
                    
                    // If we can access the video element, check if it's ended
                    if (videoElement) {
                        if (videoElement.ended || videoElement.currentTime >= videoElement.duration * 0.95) {
                            console.log('Video ended detected by manual check');
                            clearInterval(checkInterval);
                            handleVideoEnd();
                        }
                    } else {
                        // If we can't access the video element, check if enough time has passed
                        // Most videos are 15-60 seconds, so after 60 seconds we'll assume it's done
                        const elapsedTime = (Date.now() - startTime) / 1000;
                        if (elapsedTime > 60) {
                            console.log('Video likely ended (timeout after 60s)');
                            clearInterval(checkInterval);
                            handleVideoEnd();
                        }
                    }
                } catch (e) {
                    console.log('Error in video end check:', e);
                    // If we can't access the iframe content due to cross-origin restrictions,
                    // we'll rely on a timeout approach
                    const elapsedTime = (Date.now() - startTime) / 1000;
                    if (elapsedTime > 60) {
                        console.log('Video likely ended (timeout after 60s)');
                        clearInterval(checkInterval);
                        handleVideoEnd();
                    }
                }
            }, 1000);
        }
        
        // Function to handle video end
        function handleVideoEnd() {
            console.log('Handling video end');
            // Add the animation class to trigger the TikTok-style animation
            videoContainer.classList.add('video-end-animation');
            
            // After animation completes, reset and load next video
            setTimeout(() => {
                videoContainer.classList.remove('video-end-animation');
                closeVideo();
                findVideo();
            }, 500);
        }

        // Add click event listener to the submit button
        submitBtn.addEventListener('click', async () => {
            const interest = interestInput.value.trim();
            const errorMessage = document.querySelector('.error-message');
            const loadingSpinner = document.querySelector('.loading-spinner');
            
            errorMessage.style.display = 'none';
            
            if (!interest) {
                errorMessage.textContent = 'Please enter your interests';
                errorMessage.style.display = 'block';
                return;
            }

            // Check if time is 0
            if (dialValue === 0) {
                videoContainer.style.display = 'flex';
                showTimeUpMessage();
                return;
            }

            const youtubeKey = getStoredValue('youtubeKey', DEFAULT_YOUTUBE_API_KEY);

            if (!youtubeKey || youtubeKey === "REPLACE_WITH_YOUR_YOUTUBE_API_KEY") {
                document.querySelector('.api-key-modal').style.display = 'flex';
                return;
            }

            // Show loading spinner without disabling button (to maintain width)
            loadingSpinner.style.display = 'inline-block';
            
            try {
                currentInterest = interest;
                await fetchVideo(interest, true); // Reset progress when starting a new search
            } catch (error) {
                console.error("Error fetching video:", error);
                errorMessage.textContent = error.message || "An error occurred while fetching the video";
                errorMessage.style.display = 'block';
                loadingSpinner.style.display = 'none';
            }
        });

        // Fallback method when YouTube API quota is exceeded
        async function fallbackVideoSearch(query, isPortrait) {
            console.log('Using fallback video search for query:', query);
            
            // Predefined video IDs for different categories
            const videoCategories = {
                dogs: ['jtHrBsU9xhs', 'j5a0jTc9S10', 'Sg_0ZKr9fXc', 'AcL0MeVZIxM', 'kTHNpusq654'],
                cats: ['hY7m5jjJ9mM', 'CQ85sUNBK7w', 'tpiyEe_CqB4', '5dsGWM5XGdg', 'J---aiyznGQ'],
                cooking: ['VZV8h8BHz0w', 'PUP7U5vTMM0', 'bF_Mg7T6oF4', '2KR44a_5v_A', 'ETy9tuptaAM'],
                science: ['libKVRa01L8', 'FACK2knC08E', 'XFr0dk6Ca7o', 'sNhhvQGsMEc', 'wNDGgL73ihY'],
                travel: ['bHQqvYy5KYo', 'AlhB6JD0Lcc', 'QpKZrVRwZsg', 'LdviPe1iSuE', 'QW7GgK5Jk2s'],
                music: ['JGwWNGJdvx8', 'kJQP7kiw5Fk', 'RgKAFK5djSk', 'fJ9rUzIMcZQ', '9bZkp7q19f0'],
                gaming: ['hB6eY73sLV0', 'dQw4w9WgXcQ', '0J4tuFwj1uw', 'FTQbiNvZqaY', 'L_jWHffIx5E'],
                sports: ['2RQrSjw21Ik', 'oYh7zNLsHiM', 'jofNR_WkoCE', 'dv13gl0a-FA', 'ZyhrYis509A'],
                comedy: ['VDvr08sCPOc', 'dQw4w9WgXcQ', 'ZZ5LpwO-An4', 'astISOttCQ0', 'feA64wXhbjo'],
                education: ['Uy8_FdUdgtk', 'rYEDA3JcQqw', 'fWNaR-rxAic', 'y6120QOlsfU', 'OPf0YbXqDm0'],
                shorts: ['60ItHLz5WEA', 'fHI8X4OXluQ', 'xvFZjo5PgG0', 'Zi_XLOBDo_Y', 'iik25wqIuFo']
            };
            
            // Find the best matching category
            let bestCategory = 'dogs'; // Default
            let bestScore = 0;
            
            for (const category in videoCategories) {
                // Simple matching algorithm - count occurrences of category name in query
                const regex = new RegExp(category, 'gi');
                const matches = (query.match(regex) || []).length;
                
                if (matches > bestScore) {
                    bestScore = matches;
                    bestCategory = category;
                }
            }
            
            // If in portrait mode, prefer shorts
            if (isPortrait) {
                bestCategory = 'shorts';
            }
            
            // Get videos for the best matching category
            const videos = videoCategories[bestCategory] || videoCategories.dogs;
            
            // Pick a random video from the category
            const randomIndex = Math.floor(Math.random() * videos.length);
            const videoId = videos[randomIndex];
            
            console.log('Selected fallback video ID:', videoId, 'from category:', bestCategory);
            
            // Return a simplified video object
            return {
                id: videoId,
                title: 'Video about ' + bestCategory,
                channelTitle: 'Fallback Channel',
                duration: 60, // Assume 60 seconds
                viewCount: 1000000,
                relevanceScore: 1,
                language: 'en'
            };
        }
    </script>
</body>
</html>